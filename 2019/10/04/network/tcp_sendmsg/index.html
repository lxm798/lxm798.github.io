<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="tcp 层数据tcp_sendmsg返回的数据是实际copy到sk_buffer中的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182">
<meta property="og:type" content="article">
<meta property="og:title" content=".tcp_sendmsg">
<meta property="og:url" content="http://yoursite.com/2019/10/04/network/tcp_sendmsg/index.html">
<meta property="og:site_name" content="lxm798">
<meta property="og:description" content="tcp 层数据tcp_sendmsg返回的数据是实际copy到sk_buffer中的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-10-04T03:11:16.157Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content=".tcp_sendmsg">
<meta name="twitter:description" content="tcp 层数据tcp_sendmsg返回的数据是实际copy到sk_buffer中的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/10/04/network/tcp_sendmsg/">





  <title>.tcp_sendmsg | lxm798</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lxm798</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/04/network/tcp_sendmsg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxm798">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">.tcp_sendmsg</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T11:11:16+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="tcp-层数据"><a href="#tcp-层数据" class="headerlink" title="tcp 层数据"></a>tcp 层数据</h2><h3 id="tcp-sendmsg"><a href="#tcp-sendmsg" class="headerlink" title="tcp_sendmsg"></a>tcp_sendmsg</h3><p>返回的数据是实际copy到sk_buffer中的数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_sendmsg</span><span class="params">(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">iov</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	<span class="keyword">int</span> iovlen, flags;</span><br><span class="line">	<span class="keyword">int</span> mss_now, size_goal;</span><br><span class="line">	<span class="keyword">int</span> sg, err, copied;</span><br><span class="line">	<span class="keyword">long</span> timeo;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//首先对sock加锁防止下半段中断访问</span></span><br><span class="line">	lock_sock(sk);</span><br><span class="line">	TCP_CHECK_TIMER(sk);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//对于阻塞的发送模式还需设置超时时间</span></span><br><span class="line">	flags = msg-&gt;msg_flags;</span><br><span class="line">	timeo = sock_sndtimeo(sk, flags &amp; MSG_DONTWAIT);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//只有在ESTABLISHED和CLOSE_WAIT状态下对方才能够接收数据，尝试等待连接的建立</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; sk-&gt;sk_state) &amp; ~(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT))</span><br><span class="line">		<span class="keyword">if</span> ((err = sk_stream_wait_connect(sk, &amp;timeo)) != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line"> </span><br><span class="line">	clear_bit(SOCK_ASYNC_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//获取当前的MSS大小</span></span><br><span class="line">	mss_now = tcp_send_mss(sk, &amp;size_goal, flags);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*iov可以看做是一个数组，iovlen表示数组的长度。每一项都是一个数据段。*/</span></span><br><span class="line"> <span class="comment">/*struct msghdr和struct iovec在内核的消息通信机制里很常见*/</span></span><br><span class="line">	iovlen = msg-&gt;msg_iovlen;</span><br><span class="line">	iov = msg-&gt;msg_iov;<span class="comment">//获取第一个iovec</span></span><br><span class="line">	copied = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">	err = -EPIPE;</span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_err || (sk-&gt;sk_shutdown &amp; SEND_SHUTDOWN))</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br><span class="line"> </span><br><span class="line">	sg = sk-&gt;sk_route_caps &amp; NETIF_F_SG;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*循环操作iov，TCP是面向字节流而不是面向数据报的，可以发生粘包现象*/</span></span><br><span class="line">	<span class="comment">/*如果前一个SKB的小于MSS，新的数据可以将部分数据填入旧的SKB中*/</span></span><br><span class="line">	<span class="keyword">while</span> (--iovlen &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">size_t</span> seglen = iov-&gt;iov_len;					<span class="comment">//读取该段数据的长度</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">char</span> __user *from = iov-&gt;iov_base;&lt;span style=<span class="string">"white-space:pre"</span>&gt;			&lt;/span&gt;<span class="comment">//指向数据区域</span></span><br><span class="line"> </span><br><span class="line">		iov++;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">while</span> (seglen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> copy = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> max = size_goal;</span><br><span class="line"> </span><br><span class="line">			<span class="comment">//得到发送队列的尾部的skb，因为尾部才可能有剩余空间</span></span><br><span class="line">			skb = tcp_write_queue_tail(sk);				</span><br><span class="line">			<span class="keyword">if</span> (tcp_send_head(sk)) &#123;				<span class="comment">//判断是否还有未发送的数据，即sk_send_head是否非空，</span></span><br><span class="line">				<span class="keyword">if</span> (skb-&gt;ip_summed == CHECKSUM_NONE)</span><br><span class="line">					max = mss_now;</span><br><span class="line">				copy = max - skb-&gt;len;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">			<span class="comment">//不能够填充到sk_send_head指向的SKB的话，新建一个SKB</span></span><br><span class="line">			<span class="keyword">if</span> (copy &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">new_segment:</span><br><span class="line">				<span class="comment">//首先判断发送队列总长度是否超过发送缓冲区上限，即sk-&gt;sk_wmem_queued &lt; sk-&gt;sk_sndbuf</span></span><br><span class="line">				<span class="keyword">if</span> (!sk_stream_memory_free(sk))</span><br><span class="line">					<span class="keyword">goto</span> wait_for_sndbuf;		<span class="comment">//设置SOCK_NOSPACE标志位后等待空间</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">				<span class="comment">//分配一个新的SKB封装新的数据，失败的话也要等待空间,select_size返回一个skb连续数据域的长度，在2.6.38中返回的是0，表示数据全部存储在skb尾部的frags中</span></span><br><span class="line">				skb = sk_stream_alloc_skb(sk,select_size(sk, sg),sk-&gt;sk_allocation);</span><br><span class="line">				<span class="keyword">if</span> (!skb)</span><br><span class="line">					<span class="keyword">goto</span> wait_for_memory;</span><br><span class="line"> </span><br><span class="line">				<span class="keyword">if</span> (sk-&gt;sk_route_caps &amp; NETIF_F_ALL_CSUM)</span><br><span class="line">					skb-&gt;ip_summed = CHECKSUM_PARTIAL;</span><br><span class="line"> </span><br><span class="line">				skb_entail(sk, skb);					<span class="comment">//将新的SKB插入发送队列尾部</span></span><br><span class="line">				copy = size_goal;</span><br><span class="line">				max = size_goal;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">			<span class="keyword">if</span> (copy &gt; seglen)</span><br><span class="line">				copy = seglen;</span><br><span class="line"> </span><br><span class="line">			<span class="keyword">if</span> (skb_tailroom(skb) &gt; <span class="number">0</span>) &#123;				<span class="comment">//判断skb的连续数据存储区是否还有空间</span></span><br><span class="line">				<span class="keyword">if</span> (copy &gt; skb_tailroom(skb))&lt;span style=<span class="string">"white-space:pre"</span>&gt;			&lt;/span&gt;<span class="comment">//不够长的话放入部分数据</span></span><br><span class="line">					copy = skb_tailroom(skb);</span><br><span class="line">				<span class="keyword">if</span> ((err = skb_add_data(skb, from, copy)) != <span class="number">0</span>)</span><br><span class="line">					<span class="keyword">goto</span> do_fault;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//这一段是将数据复制到skb尾部的skb_shared_info中的frags，比较复杂，这样做的目的是支持物理上不连续的数据，减少合并操作提高效率</span></span><br><span class="line">				<span class="keyword">int</span> merge = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">int</span> i = skb_shinfo(skb)-&gt;nr_frags;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> = <span class="title">TCP_PAGE</span>(<span class="title">sk</span>);</span><span class="comment">//返回sk最近操作的page，每个frag的数据都是放在page中</span></span><br><span class="line">				<span class="keyword">int</span> off = TCP_OFF(sk);</span><br><span class="line"> </span><br><span class="line">				<span class="keyword">if</span> (skb_can_coalesce(skb, i, page, off) &amp;&amp;</span><br><span class="line">					off != PAGE_SIZE) &#123;</span><br><span class="line">					 <span class="comment">/* We can extend the last page</span></span><br><span class="line"><span class="comment">					  * fragment. */</span></span><br><span class="line">					 merge = <span class="number">1</span>;</span><br><span class="line">				 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == MAX_SKB_FRAGS || !sg) &#123;</span><br><span class="line">					 <span class="comment">/* Need to add new fragment and cannot</span></span><br><span class="line"><span class="comment">					  * do this because interface is non-SG,</span></span><br><span class="line"><span class="comment">					  * or because all the page slots are</span></span><br><span class="line"><span class="comment">					  * busy. */</span></span><br><span class="line">					 tcp_mark_push(tp, skb);</span><br><span class="line">					 <span class="keyword">goto</span> new_segment;</span><br><span class="line">				 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">					 <span class="keyword">if</span> (off == PAGE_SIZE) &#123; <span class="comment">//PAGE被填满了，重置</span></span><br><span class="line">					 put_page(page);</span><br><span class="line">					 TCP_PAGE(sk) = page = <span class="literal">NULL</span>;</span><br><span class="line">					 off = <span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					 off = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">					 <span class="keyword">if</span> (copy &gt; PAGE_SIZE - off) <span class="comment">//不够空间的话先拷贝部分数据</span></span><br><span class="line">					 copy = PAGE_SIZE - off;</span><br><span class="line"> </span><br><span class="line">					 <span class="keyword">if</span> (!sk_wmem_schedule(sk, copy))</span><br><span class="line">					 <span class="keyword">goto</span> wait_for_memory;</span><br><span class="line"> </span><br><span class="line">					 <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">					 <span class="comment">/* Allocate new cache page. */</span></span><br><span class="line">					 <span class="keyword">if</span> (!(page = sk_stream_alloc_page(sk)))</span><br><span class="line">					 <span class="keyword">goto</span> wait_for_memory;</span><br><span class="line">				 &#125;</span><br><span class="line"> </span><br><span class="line">				 <span class="comment">//具体的数据拷贝过程</span></span><br><span class="line">				 err = skb_copy_to_page(sk, from, skb, page,</span><br><span class="line">						off, copy);</span><br><span class="line">				 <span class="keyword">if</span> (err) &#123;</span><br><span class="line">					 <span class="comment">/* If this page was new, give it to the</span></span><br><span class="line"><span class="comment">					  * socket so it does not get leaked.</span></span><br><span class="line"><span class="comment">					  */</span></span><br><span class="line">					 <span class="keyword">if</span> (!TCP_PAGE(sk)) &#123;</span><br><span class="line">					 TCP_PAGE(sk) = page;</span><br><span class="line">					 TCP_OFF(sk) = <span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">goto</span> do_error;</span><br><span class="line">				 &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">				 <span class="comment">/* Update the skb. */</span></span><br><span class="line">				 <span class="keyword">if</span> (merge) &#123;</span><br><span class="line">					 skb_shinfo(skb)-&gt;frags[i - <span class="number">1</span>].size +=</span><br><span class="line">					 copy;</span><br><span class="line">				 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					 skb_fill_page_desc(skb, i, page, off, copy);</span><br><span class="line">					 <span class="keyword">if</span> (TCP_PAGE(sk)) &#123;</span><br><span class="line">					 get_page(page);</span><br><span class="line">					 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (off + copy &lt; PAGE_SIZE) &#123;</span><br><span class="line">					 get_page(page);</span><br><span class="line">					 TCP_PAGE(sk) = page;</span><br><span class="line">					 &#125;</span><br><span class="line">				&#125;</span><br><span class="line">				TCP_OFF(sk) = off + copy;</span><br><span class="line">			&#125;	</span><br><span class="line">			<span class="comment">//如果这一次的数据超过了最大窗口的一半，设置PUSH标志调用__tcp_push_pending_frames发送sk_send_head的所有数据</span></span><br><span class="line">			<span class="keyword">if</span> (forced_push(tp)) &#123;</span><br><span class="line">				tcp_mark_push(tp, skb);</span><br><span class="line">				__tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_PUSH);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (skb == tcp_send_head(sk))	<span class="comment">//否则如果只有当前的SKB未发送过,调用tcp_push_one发送sk_send_head的第一个数据,即当前SKB</span></span><br><span class="line">				tcp_push_one(sk, mss_now);</span><br><span class="line">				</span><br><span class="line">			<span class="comment">//上面两个判断的结果最终都会调用tcp_write_xmit函数，这个函数会从传入的sock得到sk_send_head，发送该队列上的所有数据</span></span><br><span class="line">			<span class="comment">//因为第二个判断只有一个SKB，所以只发送一个SKB.但是两者传入tcp_write_xmit的参数不一样。前者会发送MTU探测包，后者只发送一个数据包</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">wait_for_sndbuf:</span><br><span class="line">			set_bit(SOCK_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags);</span><br><span class="line">wait_for_memory:</span><br><span class="line">			<span class="keyword">if</span> (copied)</span><br><span class="line">				tcp_push(sk, flags &amp; ~MSG_MORE, mss_now, TCP_NAGLE_PUSH);</span><br><span class="line"> </span><br><span class="line">			<span class="keyword">if</span> ((err = sk_stream_wait_memory(sk, &amp;timeo)) != <span class="number">0</span>)	<span class="comment">//等待内存分配</span></span><br><span class="line">				<span class="keyword">goto</span> do_error;</span><br><span class="line"> </span><br><span class="line">			mss_now = tcp_send_mss(sk, &amp;size_goal, flags);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (copied)</span><br><span class="line">		tcp_push(sk, flags, mss_now, tp-&gt;nonagle);</span><br><span class="line">	TCP_CHECK_TIMER(sk);</span><br><span class="line">	release_sock(sk);</span><br><span class="line">	<span class="keyword">return</span> copied;</span><br><span class="line"> </span><br><span class="line">do_fault:</span><br><span class="line">	<span class="keyword">if</span> (!skb-&gt;len) &#123;</span><br><span class="line">		tcp_unlink_write_queue(skb, sk);</span><br><span class="line"> </span><br><span class="line">		tcp_check_send_head(sk, skb);</span><br><span class="line">		sk_wmem_free_skb(sk, skb);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">do_error:</span><br><span class="line">	<span class="keyword">if</span> (copied)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">out_err:</span><br><span class="line">	err = sk_stream_error(sk, flags, err);</span><br><span class="line">	TCP_CHECK_TIMER(sk);</span><br><span class="line">	release_sock(sk);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="tcp-push"><a href="#tcp-push" class="headerlink" title="tcp_push"></a>tcp_push</h2><p>tcp_sendmsg()中，在sock发送缓存不足、系统内存不足或应用层的数据都拷贝完毕等情况下，</p>
<p>都会调用tcp_push()来把已经拷贝到发送队列中的数据给发送出去。</p>
<p>tcp_push()主要做了以下事情：</p>
<ol>
<li><p>检查是否有未发送过的数据。</p>
</li>
<li><p>检查是否需要设置PSH标志。</p>
</li>
<li><p>检查是否使用了紧急模式。</p>
</li>
<li><p>检查是否需要使用自动阻塞。</p>
</li>
<li><p>尽可能地把发送队列中的skb给发送出去。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tcp_push</span><span class="params">(struct sock *sk, <span class="keyword">int</span> flags, <span class="keyword">int</span> mss_now, <span class="keyword">int</span> nonagle, <span class="keyword">int</span> size_goal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 如果没有未发送过的数据 */</span></span><br><span class="line">    <span class="keyword">if</span> (! tcp_send_head(sk))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 发送队列的最后一个skb */</span></span><br><span class="line">    skb = tcp_write_queue_tail(sk);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 如果接下来没有更多的数据需要发送，或者距离上次PUSH后又有比较多的数据，</span></span><br><span class="line"><span class="comment">     * 那么就需要设置PSH标志，让接收端马上把接收缓存中的数据提交给应用程序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (! (flags &amp; MSG_MORE) || forced_push(tp))</span><br><span class="line">        tcp_mark_push(tp, skb);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 如果设置了MSG_OOB标志，就记录紧急指针 */</span></span><br><span class="line">    tcp_mark_urg(tp, flags);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 如果需要自动阻塞小包 */</span></span><br><span class="line">    <span class="keyword">if</span> (tcp_should_autocork(sk, skb, size_goal)) &#123;</span><br><span class="line">        <span class="comment">/* avoid atomic op if TSQ_THROTTED bit is already set, 设置阻塞标志位 */</span></span><br><span class="line">        <span class="keyword">if</span> (! test_bit(TSQ_THROTTLED, &amp;tp-&gt;tsq_flags)) &#123;</span><br><span class="line">            NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPAUTOCORKING);</span><br><span class="line">            set_bit(TSQ_THROTTLED, &amp;tp-&gt;tsq_flags);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">/* It is possible TX completion already happened before we set TSQ_THROTTED.</span></span><br><span class="line"><span class="comment">         * 我的理解是，当提交给IP层的数据包都发送出去后，sk_wmem_alloc的值就会变小，</span></span><br><span class="line"><span class="comment">         * 此时这个条件就为假，之后可以发送被阻塞的数据包了。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (atomic_read(&amp;sk-&gt;sk_wmem_alloc) &gt; skb-&gt;truesize)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 如果之后还有更多的数据，那么使用TCP CORK，显式地阻塞发送 */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MSG_MORE)</span><br><span class="line">        nonagle = TCP_NAGLE_CORK;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 尽可能地把发送队列中的skb发送出去。</span></span><br><span class="line"><span class="comment">     * 如果发送失败，检查是否需要启动零窗口探测定时器。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    __tcp_push_pending_frames(sk, mss_now, nonagle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tcp_push_pending_frames()和__tcp_push_pending_frames()简单的封装了下tcp_write_xmit()。</p>
<p>从tcp_write_xmit()开始，TCP层才真正开始发送数据。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Push out any pending frames which were held back due to TCP_CORK</span></span><br><span class="line"><span class="comment"> * or attempt at coalescing tiny packets.</span></span><br><span class="line"><span class="comment"> * The socket must be locked by the caller.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> __tcp_push_pending_frames(struct sock *sk, <span class="keyword">unsigned</span> <span class="keyword">int</span> cur_mss, <span class="keyword">int</span> nonagle)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* If we are closed, the bytes will have to remain here.</span></span><br><span class="line"><span class="comment">     * In time closedown will finish, we empty the write queue and</span></span><br><span class="line"><span class="comment">     * all will be happy.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(sk-&gt;sk_state == TCP_CLOSE))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 如果发送失败 */</span></span><br><span class="line">    <span class="keyword">if</span> (tcp_write_xmit(sk, cur_mss, nonagle, <span class="number">0</span>, sk_gfp_atomic(sk, GFP_ATOMIC)))</span><br><span class="line">        tcp_check_probe_timer(sk); <span class="comment">/* 检查是否需要启用0窗口探测定时器*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="tcp-write-xmit"><a href="#tcp-write-xmit" class="headerlink" title="tcp_write_xmit"></a>tcp_write_xmit</h2><p><a href="https://blog.csdn.net/ctthuangcheng/article/details/42202477" target="_blank" rel="noopener">https://blog.csdn.net/ctthuangcheng/article/details/42202477</a><br>一、tcp_write_xmit()将发送队列上的SBK发送出去，返回值为0表示发送成功。函数执行过程如下：<br>1、检测拥塞窗口的大小。<br>2、检测当前报文是否完全处在发送窗口内。<br>3、检测报文是否使用nagle算法进行发送。<br>4、通过以上检测后将该SKB发送出去。<br>5、循环检测发送队列上所有未发送的SKB。</p>
<p>如果不在发送或者接受窗口内，或者受到nagle/塞子的限制，写到sk_buffer后就返回了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tcp_write_xmit</span><span class="params">(struct sock *sk, <span class="keyword">unsigned</span> <span class="keyword">int</span> mss_now, <span class="keyword">int</span> nonagle,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">int</span> push_one, <span class="keyword">gfp_t</span> gfp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tso_segs, sent_pkts;</span><br><span class="line">    <span class="keyword">int</span> cwnd_quota;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*sent_pkts用来统计函数中已发送报文总数。*/</span></span><br><span class="line">    sent_pkts = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!push_one) &#123;</span><br><span class="line">        <span class="comment">/* Do MTU probing. */</span></span><br><span class="line">        result = tcp_mtu_probe(sk);</span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sent_pkts = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*13~21首先初始化为0，接着发送一个路径MTU探测报文，如果成功则发送报文数加1。*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*如果发送队列不为空，则准备开始发送报文*/</span></span><br><span class="line">    <span class="keyword">while</span> ((skb = tcp_send_head(sk))) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> limit;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/*设置有关TSO的信息，包括GSO类型，GSO分段的大小等等。这些信息是准备给软件TSO分段使用的。</span></span><br><span class="line"><span class="comment">        如果网络设备不支持TSO，但又使用了TSO功能，则报文在提交给网络设备之前，需进行软分段，即由代码实现TSO分段。*/</span></span><br><span class="line">        tso_segs = tcp_init_tso_segs(sk, skb, mss_now);</span><br><span class="line">        BUG_ON(!tso_segs);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/*检测拥塞窗口的大小，如果为0，则说明拥塞窗口已满，目前不能发送。</span></span><br><span class="line"><span class="comment">        拿拥塞窗口和正在网络上传输的包数目相比，如果拥塞窗口还大，则返回拥塞窗口减掉正在网络上传输的包数目剩下的大小。</span></span><br><span class="line"><span class="comment">        该函数目的是判断正在网络上传输的包数目是否超过拥塞窗口，如果超过了，则不发送。</span></span><br><span class="line"><span class="comment">        tcp_cwnd_test()源代码见段二*/</span></span><br><span class="line">        cwnd_quota = tcp_cwnd_test(tp, skb);</span><br><span class="line">        <span class="keyword">if</span> (!cwnd_quota)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">/*检测当前报文是否完全处于发送窗口内，如果是则可以发送，否则不能发送*/</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!tcp_snd_wnd_test(tp, skb, mss_now)))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*tso_segs=1表示无需tso分段*/</span></span><br><span class="line">        <span class="keyword">if</span> (tso_segs == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/*根据nagle算法，计算是否需要发送数据*/</span></span><br><span class="line">            <span class="keyword">if</span> (unlikely(!tcp_nagle_test(tp, skb, mss_now,</span><br><span class="line">                         (tcp_skb_is_last(sk, skb) ?</span><br><span class="line">                         nonagle : TCP_NAGLE_PUSH))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">/*如果需要TSO分段，则检测该报文是否应该延时发送。tcp_tso_should_defer()用来检测GSO段是否需要延时发送。</span></span><br><span class="line"><span class="comment">            在段中有FIN标志，或者不处于open拥塞状态，或者TSO段延时超过2个时钟滴答，或者拥塞窗口和发送窗口的最小值大于64K或三倍的当前有效MSS，</span></span><br><span class="line"><span class="comment">            在这些情况下会立即发送，而其他情况下会延时发送，这样主要是为了减少软GSO分段的次数，以提高性能。*/</span></span><br><span class="line">            <span class="keyword">if</span> (!push_one &amp;&amp; tcp_tso_should_defer(sk, skb))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*limit为再次分段的段长，初始化为当前MSS*/</span></span><br><span class="line">        limit = mss_now; </span><br><span class="line">      <span class="comment">/*在TSO分片大于1并且不是URG模式下，通过mss_now计算limit的值</span></span><br><span class="line"><span class="comment">        以发送窗口和拥塞窗口的最小值作为分段段长*/</span></span><br><span class="line">        <span class="keyword">if</span> (tso_segs &gt; <span class="number">1</span> &amp;&amp; !tcp_urg_mode(tp))</span><br><span class="line">            limit = tcp_mss_split_point(sk, skb, mss_now,</span><br><span class="line">                         cwnd_quota);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*如果SKB中的数据长度大于分段段长，则调用tso_fragment()根据该段长进行分段，如果分段失败则暂不发送*/</span></span><br><span class="line">        <span class="keyword">if</span> (skb-&gt;len &gt; limit &amp;&amp;</span><br><span class="line">         unlikely(tso_fragment(sk, skb, limit, mss_now, gfp)))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">/*line61~71：根据条件，可能需要对SKB中的报文进行分段处理，分段的报文包括两种：一种是普通的用MSS分段的报文，另一种则是TSO分段的报文。</span></span><br><span class="line"><span class="comment">        能否发送报文主要取决于两个条件：一是报文需完全在发送窗口中，而是拥塞窗口未满。第一种报文，应该不会再分段了，因为在tcp_sendmsg()中创建报文的SKB时已经根据MSS处理了，</span></span><br><span class="line"><span class="comment">        而第二种报文，则一般情况下都会大于MSS，因为通过TSO分段的段有可能大于拥塞窗口的剩余空间，如果是这样，就需要以发送窗口和拥塞窗口的最小值作为段长对报文再次分段。*/</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">/*更新TCP时间戳，记录此报文发送的时间，</span></span><br><span class="line"><span class="comment">        #define tcp_time_stamp	 ((__u32)(jiffies))*/</span></span><br><span class="line">        TCP_SKB_CB(skb)-&gt;when = tcp_time_stamp;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*调用tcp_transmit_skb()发送TCP段，其中第三个参数1表示是否需要克隆被发送的报文，详见后续对此函数的分析*/</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(tcp_transmit_skb(sk, skb, <span class="number">1</span>, gfp)))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Advance the send_head. This one is sent out.</span></span><br><span class="line"><span class="comment">         * This call will increment packets_out.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">      <span class="comment">/*调用tcp_event_new_data_sent()--&gt;tcp_advance_send_head()更新sk_send_head，即取发送队列中的下一个SKB。</span></span><br><span class="line"><span class="comment">        同时更新snd_nxt，即等待发送的下一个TCP段的序号，然后统计发出但未得到确认的数据报个数。</span></span><br><span class="line"><span class="comment">        最后如果发送该报文前没有需要确认的报文，则复位重传定时器，对本次发送的报文做重传超时计时。*/</span></span><br><span class="line">        tcp_event_new_data_sent(sk, skb);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/*更新struct tcp_sock中的snd_sml字段。snd_sml表示最近发送的小包(小于MSS的段)的最后一个字节序号，</span></span><br><span class="line"><span class="comment">        在发送成功后，如果报文小于MSS，即更新该字段，主要用来判断是否启动nagle算法*/</span></span><br><span class="line">        tcp_minshall_update(tp, mss_now, skb);</span><br><span class="line">        sent_pkts++;<span class="comment">//更新已发送报文总数</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (push_one)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*如果本次有数据发送，则对TCP拥塞窗口进行检查确认。*/</span></span><br><span class="line">    <span class="keyword">if</span> (likely(sent_pkts)) &#123;</span><br><span class="line">        tcp_cwnd_validate(sk);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*如果本次没有数据发送，则根据已发送但未确认的报文数packets_out和sk_send_head返回，packets_out不为零或sk_send_head为空都视为有数据发出，因此返回成功。*/</span></span><br><span class="line">    <span class="keyword">return</span> !tp-&gt;packets_out &amp;&amp; tcp_send_head(sk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tcp-init-tso-segs-函数"><a href="#tcp-init-tso-segs-函数" class="headerlink" title="tcp_init_tso_segs()函数"></a>tcp_init_tso_segs()函数</h3><p>该函数根据当前mss的值重新设置数据包中的struct skb_shared_info内的关于GSO的内容项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tcp_init_tso_segs</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">unsigned</span> <span class="keyword">int</span> mss_now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tso_segs = tcp_skb_pcount(skb);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!tso_segs || (tso_segs &gt; <span class="number">1</span> &amp;&amp; tcp_skb_mss(skb) != mss_now)) &#123;</span><br><span class="line">        tcp_set_skb_tso_segs(sk, skb, mss_now);</span><br><span class="line">        tso_segs = tcp_skb_pcount(skb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tso_segs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">tcp_cwnd_test</span><span class="params">(struct tcp_sock *tp,</span></span></span><br><span class="line"><span class="function"><span class="params">                     struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u32 in_flight, cwnd;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Don't be strict about the congestion window for the final FIN. */</span></span><br><span class="line">    <span class="comment">/*对FIN包不检测，让他通过*/</span></span><br><span class="line">    <span class="keyword">if</span> ((TCP_SKB_CB(skb)-&gt;flags &amp; TCPHDR_FIN) &amp;&amp; tcp_skb_pcount(skb) == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*计算正在网络上传输的包数目*/</span></span><br><span class="line">    in_flight = tcp_packets_in_flight(tp);</span><br><span class="line">    <span class="comment">/*获取当前拥塞窗口的大小，snd_cwnd表示当前拥塞窗口的大小*/</span></span><br><span class="line">    cwnd = tp-&gt;snd_cwnd;</span><br><span class="line">    <span class="keyword">if</span> (in_flight &lt; cwnd)</span><br><span class="line">        <span class="keyword">return</span> (cwnd - in_flight);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="tcp-transmit-skb"><a href="#tcp-transmit-skb" class="headerlink" title="tcp_transmit_skb"></a>tcp_transmit_skb</h2><p><a href="https://blog.csdn.net/ctthuangcheng/article/details/42202927" target="_blank" rel="noopener">https://blog.csdn.net/ctthuangcheng/article/details/42202927</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tcp_transmit_skb</span><span class="params">(struct sock *sk, struct sk_buff *skb, <span class="keyword">int</span> clone_it,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">gfp_t</span> gfp_mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> = <span class="title">inet_csk</span>(<span class="title">sk</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_skb_cb</span> *<span class="title">tcb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_out_options</span> <span class="title">opts</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> tcp_options_size, tcp_header_size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_md5sig_key</span> *<span class="title">md5</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"> </span><br><span class="line">    BUG_ON(!skb || !tcp_skb_pcount(skb));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* If congestion control is doing timestamping, we must</span></span><br><span class="line"><span class="comment">     * take such a timestamp before we potentially clone/copy.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">/*如果拥塞控制需要做时间才有，则必须在克隆或者拷贝报文之前设置一个时间戳。</span></span><br><span class="line"><span class="comment">    linux支持了多达十种拥塞控制算法，但并不是每种算中都需要做时间采样的，</span></span><br><span class="line"><span class="comment">    因此在设置时间戳前先判断当前的拥塞算法是否需要做时间采样。*/</span></span><br><span class="line">    <span class="keyword">if</span> (icsk-&gt;icsk_ca_ops-&gt;flags &amp; TCP_CONG_RTT_STAMP)</span><br><span class="line">        __net_timestamp(skb);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*根据传递进来的clone_it参数来确定是否需要克隆待发送的报文。*/</span></span><br><span class="line">    <span class="keyword">if</span> (likely(clone_it)) &#123;</span><br><span class="line">        <span class="comment">/*如果skb已经被clone，则只能复制该skb的数据到新分配的skb中*/</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(skb_cloned(skb)))</span><br><span class="line">            skb = pskb_copy(skb, gfp_mask);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">/*clone新的skb*/</span></span><br><span class="line">            skb = skb_clone(skb, gfp_mask);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(!skb))</span><br><span class="line">            <span class="keyword">return</span> -ENOBUFS;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*获取INET层和TCP层的传输控制块、skb中的TCP私有数据块。*/</span></span><br><span class="line">    inet = inet_sk(sk);</span><br><span class="line">    tp = tcp_sk(sk);</span><br><span class="line">    tcb = TCP_SKB_CB(skb);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;opts, <span class="number">0</span>, <span class="keyword">sizeof</span>(opts));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*根据TCP选项重新调整TCP首部的长度。*/</span></span><br><span class="line">    <span class="comment">/*判断当前TCP报文是否是SYN段，因为有些选项只能出现在SYN报文中，需做特别处理。*/</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(tcb-&gt;flags &amp; TCPHDR_SYN))</span><br><span class="line">        tcp_options_size = tcp_syn_options(sk, skb, &amp;opts, &amp;md5);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tcp_options_size = tcp_established_options(sk, skb, &amp;opts, &amp;md5);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*tcp首部的总长度等于可选长度加上struct tcphdr。*/</span></span><br><span class="line">    tcp_header_size = tcp_options_size + <span class="keyword">sizeof</span>(struct tcphdr);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*如果已发出但未确认的数据包数目为零，则只初始化拥塞控制，并开始跟踪该连接的RTT。*/</span></span><br><span class="line">    <span class="keyword">if</span> (tcp_packets_in_flight(tp) == <span class="number">0</span>)</span><br><span class="line">        tcp_ca_event(sk, CA_EVENT_TX_START);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*调用skb_push()在数据部分的头部添加TCP首部，长度即为之前计算得到的那个tcp_header_size，实际上是把data指针往上移。*/</span></span><br><span class="line">    skb_push(skb, tcp_header_size);</span><br><span class="line">    skb_reset_transport_header(skb);</span><br><span class="line">    <span class="comment">/*SKB已添加到发送队列中，但是从SKB的角度去看还不知道他是属于哪个传输控制块，因此调用skb_set_owner_w设置该SKB的宿主。*/</span></span><br><span class="line">    skb_set_owner_w(skb, sk);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Build TCP header and checksum it. */</span></span><br><span class="line">    <span class="comment">/*填充TCP首部中的源端口source、目的端口dest、TCP报文的序号seq、确认序号ack_seq以及各个标志位*/</span></span><br><span class="line">    th = tcp_hdr(skb);</span><br><span class="line">    th-&gt;source        = inet-&gt;inet_sport;</span><br><span class="line">    th-&gt;dest        = inet-&gt;inet_dport;</span><br><span class="line">    th-&gt;seq            = htonl(tcb-&gt;seq);</span><br><span class="line">    th-&gt;ack_seq        = htonl(tp-&gt;rcv_nxt);</span><br><span class="line">    *(((__be16 *)th) + <span class="number">6</span>)    = htons(((tcp_header_size &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">12</span>) |</span><br><span class="line">                    tcb-&gt;flags);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*分两种情况设置TCP首部的接收窗口的大小*/</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(tcb-&gt;flags &amp; TCPHDR_SYN)) &#123;</span><br><span class="line">        <span class="comment">/* RFC1323: The window in SYN &amp; SYN/ACK segments</span></span><br><span class="line"><span class="comment">         * is never scaled.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/*如果是SYN段，则设置接收窗口初始值为rcv_wnd*/</span></span><br><span class="line">        th-&gt;window    = htons(min(tp-&gt;rcv_wnd, <span class="number">65535U</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*如果是其他的报文，则调用tcp_select_window()计算当前接收窗口的大小。*/</span></span><br><span class="line">        th-&gt;window    = htons(tcp_select_window(sk));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*初始化TCP首部的校验码和紧急指针，具体请参考TCP协议中的首部定义。*/</span></span><br><span class="line">    th-&gt;check        = <span class="number">0</span>;</span><br><span class="line">    th-&gt;urg_ptr        = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* The urg_mode check is necessary during a below snd_una win probe */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(tcp_urg_mode(tp) &amp;&amp; before(tcb-&gt;seq, tp-&gt;snd_up))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (before(tp-&gt;snd_up, tcb-&gt;seq + <span class="number">0x10000</span>)) &#123;</span><br><span class="line">            th-&gt;urg_ptr = htons(tp-&gt;snd_up - tcb-&gt;seq);</span><br><span class="line">            th-&gt;urg = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (after(tcb-&gt;seq + <span class="number">0xFFFF</span>, tp-&gt;snd_nxt)) &#123;</span><br><span class="line">            th-&gt;urg_ptr = htons(<span class="number">0xFFFF</span>);</span><br><span class="line">            th-&gt;urg = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    tcp_options_write((__be32 *)(th + <span class="number">1</span>), tp, &amp;opts);</span><br><span class="line">    <span class="keyword">if</span> (likely((tcb-&gt;flags &amp; TCPHDR_SYN) == <span class="number">0</span>))</span><br><span class="line">        TCP_ECN_send(sk, skb, tcp_header_size);</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TCP_MD5SIG</span></span><br><span class="line">    <span class="comment">/* Calculate the MD5 hash, as we have all we need now */</span></span><br><span class="line">    <span class="keyword">if</span> (md5) &#123;</span><br><span class="line">        sk_nocaps_add(sk, NETIF_F_GSO_MASK);</span><br><span class="line">        tp-&gt;af_specific-&gt;calc_md5_hash(opts.hash_location,</span><br><span class="line">                     md5, sk, <span class="literal">NULL</span>, skb);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    icsk-&gt;icsk_af_ops-&gt;send_check(sk, skb);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (likely(tcb-&gt;flags &amp; TCPHDR_ACK))</span><br><span class="line">        tcp_event_ack_sent(sk, tcp_skb_pcount(skb));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (skb-&gt;len != tcp_header_size)</span><br><span class="line">        tcp_event_data_sent(tp, skb, sk);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (after(tcb-&gt;end_seq, tp-&gt;snd_nxt) || tcb-&gt;seq == tcb-&gt;end_seq)</span><br><span class="line">        TCP_ADD_STATS(sock_net(sk), TCP_MIB_OUTSEGS,</span><br><span class="line">             tcp_skb_pcount(skb));</span><br><span class="line">    <span class="comment">/*调用发送接口queue_xmit发送报文，进入到ip层，如果失败返回错误码。在TCP中该接口实现函数为ip_queue_xmit()*/</span></span><br><span class="line">    err = icsk-&gt;icsk_af_ops-&gt;queue_xmit(skb);</span><br><span class="line">    <span class="keyword">if</span> (likely(err &lt;= <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"> </span><br><span class="line">    tcp_enter_cwr(sk, <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> net_xmit_eval(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://www.linuxtcpipstack.com/634.html" target="_blank" rel="noopener">http://www.linuxtcpipstack.com/634.html</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tcp_transmit_skb</span><span class="params">(struct sock *sk, struct sk_buff *skb, <span class="keyword">int</span> clone_it,</span></span></span><br><span class="line"><span class="function"><span class="params">			    <span class="keyword">gfp_t</span> gfp_mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> = <span class="title">inet_csk</span>(<span class="title">sk</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_skb_cb</span> *<span class="title">tcb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_out_options</span> <span class="title">opts</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> tcp_options_size, tcp_header_size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_md5sig_key</span> *<span class="title">md5</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	BUG_ON(!skb || !tcp_skb_pcount(skb));</span><br><span class="line">	tp = tcp_sk(sk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 需要克隆 */</span></span><br><span class="line">	<span class="keyword">if</span> (clone_it) &#123;</span><br><span class="line">		skb_mstamp_get(&amp;skb-&gt;skb_mstamp);</span><br><span class="line">		TCP_SKB_CB(skb)-&gt;tx.in_flight = TCP_SKB_CB(skb)-&gt;end_seq</span><br><span class="line">			- tp-&gt;snd_una;</span><br><span class="line">		tcp_rate_skb_sent(sk, skb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果skb已经是被克隆过的，那么只能复制 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(skb_cloned(skb)))</span><br><span class="line">			skb = pskb_copy(skb, gfp_mask);</span><br><span class="line">        <span class="comment">/* 未被克隆过，则克隆之 */</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			skb = skb_clone(skb, gfp_mask);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 复制或者克隆失败 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!skb))</span><br><span class="line">			<span class="keyword">return</span> -ENOBUFS;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	inet = inet_sk(sk);</span><br><span class="line">	tcb = TCP_SKB_CB(skb);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;opts, <span class="number">0</span>, <span class="keyword">sizeof</span>(opts));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算syn包tcp选项长度 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(tcb-&gt;tcp_flags &amp; TCPHDR_SYN))</span><br><span class="line">		tcp_options_size = tcp_syn_options(sk, skb, &amp;opts, &amp;md5);</span><br><span class="line">    <span class="comment">/* 计算已连接状态tcp选项长度 */</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		tcp_options_size = tcp_established_options(sk, skb, &amp;opts,</span><br><span class="line">							   &amp;md5);</span><br><span class="line">    <span class="comment">/* 计算tcp头部长度 */</span></span><br><span class="line">	tcp_header_size = tcp_options_size + <span class="keyword">sizeof</span>(struct tcphdr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if no packet is in qdisc/device queue, then allow XPS to select</span></span><br><span class="line"><span class="comment">	 * another queue. We can be called from tcp_tsq_handler()</span></span><br><span class="line"><span class="comment">	 * which holds one reference to sk_wmem_alloc.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">TODO:</span> Ideally, in-flight pure ACK packets should not matter here.</span></span><br><span class="line"><span class="comment">	 * One way to get this would be to set skb-&gt;truesize = 2 on them.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	skb-&gt;ooo_okay = sk_wmem_alloc_get(sk) &lt; SKB_TRUESIZE(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If we had to use memory reserve to allocate this skb,</span></span><br><span class="line"><span class="comment">	 * this might cause drops if packet is looped back :</span></span><br><span class="line"><span class="comment">	 * Other socket might not have SOCK_MEMALLOC.</span></span><br><span class="line"><span class="comment">	 * Packets not looped back do not care about pfmemalloc.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	skb-&gt;pfmemalloc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 加入tcp头 */</span></span><br><span class="line">	skb_push(skb, tcp_header_size);</span><br><span class="line">	skb_reset_transport_header(skb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 与控制块解除关联 */</span></span><br><span class="line">	skb_orphan(skb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 与控制块建立关联 */</span></span><br><span class="line">	skb-&gt;sk = sk;</span><br><span class="line">	skb-&gt;destructor = skb_is_tcp_pure_ack(skb) ? __sock_wfree : tcp_wfree;</span><br><span class="line">	skb_set_hash_from_sk(skb, sk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 增加分配的内存 */</span></span><br><span class="line">	atomic_add(skb-&gt;truesize, &amp;sk-&gt;sk_wmem_alloc);</span><br><span class="line"></span><br><span class="line">	skb_set_dst_pending_confirm(skb, sk-&gt;sk_dst_pending_confirm);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Build TCP header and checksum it. */</span></span><br><span class="line">    <span class="comment">/* 构造tcp头 */</span></span><br><span class="line">	th = (struct tcphdr *)skb-&gt;data;</span><br><span class="line">	th-&gt;source		= inet-&gt;inet_sport;</span><br><span class="line">	th-&gt;dest		= inet-&gt;inet_dport;</span><br><span class="line">	th-&gt;seq			= htonl(tcb-&gt;seq);</span><br><span class="line">	th-&gt;ack_seq		= htonl(tp-&gt;rcv_nxt);</span><br><span class="line">	*(((__be16 *)th) + <span class="number">6</span>)	= htons(((tcp_header_size &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">12</span>) |</span><br><span class="line">					tcb-&gt;tcp_flags);</span><br><span class="line"></span><br><span class="line">	th-&gt;check		= <span class="number">0</span>;</span><br><span class="line">	th-&gt;urg_ptr		= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The urg_mode check is necessary during a below snd_una win probe */</span></span><br><span class="line">    <span class="comment">/* 紧急模式 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(tcp_urg_mode(tp) &amp;&amp; before(tcb-&gt;seq, tp-&gt;snd_up))) &#123;</span><br><span class="line">		<span class="keyword">if</span> (before(tp-&gt;snd_up, tcb-&gt;seq + <span class="number">0x10000</span>)) &#123;</span><br><span class="line">			th-&gt;urg_ptr = htons(tp-&gt;snd_up - tcb-&gt;seq);</span><br><span class="line">			th-&gt;urg = <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (after(tcb-&gt;seq + <span class="number">0xFFFF</span>, tp-&gt;snd_nxt)) &#123;</span><br><span class="line">			th-&gt;urg_ptr = htons(<span class="number">0xFFFF</span>);</span><br><span class="line">			th-&gt;urg = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 写入tcp选项 */</span></span><br><span class="line">	tcp_options_write((__be32 *)(th + <span class="number">1</span>), tp, &amp;opts);</span><br><span class="line">	skb_shinfo(skb)-&gt;gso_type = sk-&gt;sk_gso_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* syn需要选择通告窗口 */</span></span><br><span class="line">	<span class="keyword">if</span> (likely(!(tcb-&gt;tcp_flags &amp; TCPHDR_SYN))) &#123;</span><br><span class="line">		th-&gt;window      = htons(tcp_select_window(sk));</span><br><span class="line">		tcp_ecn_send(sk, skb, th, tcp_header_size);</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="comment">/* 其他需要设置接收窗口 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* RFC1323: The window in SYN &amp; SYN/ACK segments</span></span><br><span class="line"><span class="comment">		 * is never scaled.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		th-&gt;window	= htons(min(tp-&gt;rcv_wnd, <span class="number">65535U</span>));</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TCP_MD5SIG</span></span><br><span class="line">	<span class="comment">/* Calculate the MD5 hash, as we have all we need now */</span></span><br><span class="line">	<span class="keyword">if</span> (md5) &#123;</span><br><span class="line">		sk_nocaps_add(sk, NETIF_F_GSO_MASK);</span><br><span class="line">		tp-&gt;af_specific-&gt;calc_md5_hash(opts.hash_location,</span><br><span class="line">					       md5, sk, skb);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* 计算校验和 */</span></span><br><span class="line">	icsk-&gt;icsk_af_ops-&gt;send_check(sk, skb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ack处理，快速模式数量-以及定时器清除 */</span></span><br><span class="line">	<span class="keyword">if</span> (likely(tcb-&gt;tcp_flags &amp; TCPHDR_ACK))</span><br><span class="line">		tcp_event_ack_sent(sk, tcp_skb_pcount(skb));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 有数据要发送 */</span></span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;len != tcp_header_size) &#123;</span><br><span class="line">		tcp_event_data_sent(tp, sk);</span><br><span class="line">		tp-&gt;data_segs_out += tcp_skb_pcount(skb);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 统计分段数 */</span></span><br><span class="line">	<span class="keyword">if</span> (after(tcb-&gt;end_seq, tp-&gt;snd_nxt) || tcb-&gt;seq == tcb-&gt;end_seq)</span><br><span class="line">		TCP_ADD_STATS(sock_net(sk), TCP_MIB_OUTSEGS,</span><br><span class="line">			      tcp_skb_pcount(skb));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送的总分段数统计 */</span></span><br><span class="line">	tp-&gt;segs_out += tcp_skb_pcount(skb);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* OK, its time to fill skb_shinfo(skb)-&gt;gso_&#123;segs|size&#125; */</span></span><br><span class="line">    <span class="comment">/* skb中分段数统计 */</span></span><br><span class="line">	skb_shinfo(skb)-&gt;gso_segs = tcp_skb_pcount(skb);</span><br><span class="line">	skb_shinfo(skb)-&gt;gso_size = tcp_skb_mss(skb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Our usage of tstamp should remain private */</span></span><br><span class="line">	skb-&gt;tstamp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Cleanup our debris for IP stacks */</span></span><br><span class="line">    <span class="comment">/* 清空tcb，ip层要使用 */</span></span><br><span class="line">	<span class="built_in">memset</span>(skb-&gt;cb, <span class="number">0</span>, max(<span class="keyword">sizeof</span>(struct inet_skb_parm),</span><br><span class="line">			       <span class="keyword">sizeof</span>(struct inet6_skb_parm)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送skb */</span></span><br><span class="line">	err = icsk-&gt;icsk_af_ops-&gt;queue_xmit(sk, skb, &amp;inet-&gt;cork.fl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送成功或失败 */</span></span><br><span class="line">	<span class="keyword">if</span> (likely(err &lt;= <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 拥塞控制 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 进入cwr */</span></span><br><span class="line">	tcp_enter_cwr(sk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 根据err返回成功与否 */</span></span><br><span class="line">	<span class="keyword">return</span> net_xmit_eval(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ip层数据传输"><a href="#ip层数据传输" class="headerlink" title="ip层数据传输"></a>ip层数据传输</h2><h3 id="ip-queue-xmit"><a href="#ip-queue-xmit" class="headerlink" title="ip_queue_xmit"></a>ip_queue_xmit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Note: skb-&gt;sk can be different from sk, in case of tunnels */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ip_queue_xmit</span><span class="params">(struct sock *sk, struct sk_buff *skb, struct flowi *fl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> = <span class="title">inet_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> = <span class="title">sock_net</span>(<span class="title">sk</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_options_rcu</span> *<span class="title">inet_opt</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">flowi4</span> *<span class="title">fl4</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rtable</span> *<span class="title">rt</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Skip all of this if the packet is already routed,</span></span><br><span class="line"><span class="comment">	 * f.e. by something like SCTP.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	inet_opt = rcu_dereference(inet-&gt;inet_opt);</span><br><span class="line">	fl4 = &amp;fl-&gt;u.ip4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取skb中的路由缓存 */</span></span><br><span class="line">	rt = skb_rtable(skb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* skb中有缓存则跳转处理 */</span></span><br><span class="line">	<span class="keyword">if</span> (rt)</span><br><span class="line">		<span class="keyword">goto</span> packet_routed;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make sure we can route this packet. */</span></span><br><span class="line">    <span class="comment">/* 检查控制块中的路由缓存 */</span></span><br><span class="line">	rt = (struct rtable *)__sk_dst_check(sk, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* 缓存过期 */</span></span><br><span class="line">	<span class="keyword">if</span> (!rt) &#123;</span><br><span class="line">		__be32 daddr;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Use correct destination address if we have options. */</span></span><br><span class="line">        <span class="comment">/* 目的地址 */</span></span><br><span class="line">		daddr = inet-&gt;inet_daddr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 严格路由选项 */</span></span><br><span class="line">		<span class="keyword">if</span> (inet_opt &amp;&amp; inet_opt-&gt;opt.srr)</span><br><span class="line">			daddr = inet_opt-&gt;opt.faddr;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* If this fails, retransmit mechanism of transport layer will</span></span><br><span class="line"><span class="comment">		 * keep trying until route appears or the connection times</span></span><br><span class="line"><span class="comment">		 * itself out.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">/* 查找路由缓存 */</span></span><br><span class="line">		rt = ip_route_output_ports(net, fl4, sk,</span><br><span class="line">					   daddr, inet-&gt;inet_saddr,</span><br><span class="line">					   inet-&gt;inet_dport,</span><br><span class="line">					   inet-&gt;inet_sport,</span><br><span class="line">					   sk-&gt;sk_protocol,</span><br><span class="line">					   RT_CONN_FLAGS(sk),</span><br><span class="line">					   sk-&gt;sk_bound_dev_if);</span><br><span class="line">        <span class="comment">/* 失败 */</span></span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(rt))</span><br><span class="line">			<span class="keyword">goto</span> no_route;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 设置控制块的路由缓存 */</span></span><br><span class="line">		sk_setup_caps(sk, &amp;rt-&gt;dst);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将路由设置到skb中 */</span></span><br><span class="line">	skb_dst_set_noref(skb, &amp;rt-&gt;dst);</span><br><span class="line"></span><br><span class="line">packet_routed:</span><br><span class="line">    <span class="comment">/* 严格路由选项    &amp;&amp;使用网关，无路由 */</span></span><br><span class="line">	<span class="keyword">if</span> (inet_opt &amp;&amp; inet_opt-&gt;opt.is_strictroute &amp;&amp; rt-&gt;rt_uses_gateway)</span><br><span class="line">		<span class="keyword">goto</span> no_route;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* OK, we know where to send it, allocate and build IP header. */</span></span><br><span class="line">    <span class="comment">/* 加入ip头 */</span></span><br><span class="line">	skb_push(skb, <span class="keyword">sizeof</span>(struct iphdr) + (inet_opt ? inet_opt-&gt;opt.optlen : <span class="number">0</span>));</span><br><span class="line">	skb_reset_network_header(skb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造ip头 */</span></span><br><span class="line">    iph = ip_hdr(skb);</span><br><span class="line">	*((__be16 *)iph) = htons((<span class="number">4</span> &lt;&lt; <span class="number">12</span>) | (<span class="number">5</span> &lt;&lt; <span class="number">8</span>) | (inet-&gt;tos &amp; <span class="number">0xff</span>));</span><br><span class="line">	<span class="keyword">if</span> (ip_dont_fragment(sk, &amp;rt-&gt;dst) &amp;&amp; !skb-&gt;ignore_df)</span><br><span class="line">		iph-&gt;frag_off = htons(IP_DF);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		iph-&gt;frag_off = <span class="number">0</span>;</span><br><span class="line">	iph-&gt;ttl      = ip_select_ttl(inet, &amp;rt-&gt;dst);</span><br><span class="line">	iph-&gt;protocol = sk-&gt;sk_protocol;</span><br><span class="line">	ip_copy_addrs(iph, fl4);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Transport layer set skb-&gt;h.foo itself. */</span></span><br><span class="line">    <span class="comment">/* 构造ip选项 */</span></span><br><span class="line">	<span class="keyword">if</span> (inet_opt &amp;&amp; inet_opt-&gt;opt.optlen) &#123;</span><br><span class="line">		iph-&gt;ihl += inet_opt-&gt;opt.optlen &gt;&gt; <span class="number">2</span>;</span><br><span class="line">		ip_options_build(skb, &amp;inet_opt-&gt;opt, inet-&gt;inet_daddr, rt, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置id */</span></span><br><span class="line">	ip_select_ident_segs(net, skb, sk,</span><br><span class="line">			     skb_shinfo(skb)-&gt;gso_segs ?: <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO : should we use skb-&gt;sk here instead of sk ? */</span></span><br><span class="line">    <span class="comment">/* QOS等级 */</span></span><br><span class="line">	skb-&gt;priority = sk-&gt;sk_priority;</span><br><span class="line">	skb-&gt;mark = sk-&gt;sk_mark;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输出 */</span></span><br><span class="line">	res = ip_local_out(net, sk, skb);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">no_route:</span><br><span class="line">    <span class="comment">/* 无路由处理 */</span></span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	IP_INC_STATS(net, IPSTATS_MIB_OUTNOROUTES);</span><br><span class="line">	kfree_skb(skb);</span><br><span class="line">	<span class="keyword">return</span> -EHOSTUNREACH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ip_build_and_send_pkt</span><span class="params">(struct sk_buff *skb, <span class="keyword">const</span> struct sock *sk,</span></span></span><br><span class="line"><span class="function"><span class="params">			  __be32 saddr, __be32 daddr, struct ip_options_rcu *opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> = <span class="title">inet_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rtable</span> *<span class="title">rt</span> = <span class="title">skb_rtable</span>(<span class="title">skb</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> = <span class="title">sock_net</span>(<span class="title">sk</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Build the IP header. */</span></span><br><span class="line">    <span class="comment">/* 构造ip头 */</span></span><br><span class="line">	skb_push(skb, <span class="keyword">sizeof</span>(struct iphdr) + (opt ? opt-&gt;opt.optlen : <span class="number">0</span>));</span><br><span class="line">	skb_reset_network_header(skb);</span><br><span class="line">	iph = ip_hdr(skb);</span><br><span class="line">	iph-&gt;version  = <span class="number">4</span>;</span><br><span class="line">	iph-&gt;ihl      = <span class="number">5</span>;</span><br><span class="line">	iph-&gt;tos      = inet-&gt;tos;</span><br><span class="line">	iph-&gt;ttl      = ip_select_ttl(inet, &amp;rt-&gt;dst);</span><br><span class="line">	iph-&gt;daddr    = (opt &amp;&amp; opt-&gt;opt.srr ? opt-&gt;opt.faddr : daddr);</span><br><span class="line">	iph-&gt;saddr    = saddr;</span><br><span class="line">	iph-&gt;protocol = sk-&gt;sk_protocol;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分片与否 */</span></span><br><span class="line">	<span class="keyword">if</span> (ip_dont_fragment(sk, &amp;rt-&gt;dst)) &#123;</span><br><span class="line">		iph-&gt;frag_off = htons(IP_DF);</span><br><span class="line">		iph-&gt;id = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		iph-&gt;frag_off = <span class="number">0</span>;</span><br><span class="line">		__ip_select_ident(net, iph, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 选项 */</span></span><br><span class="line">	<span class="keyword">if</span> (opt &amp;&amp; opt-&gt;opt.optlen) &#123;</span><br><span class="line">		iph-&gt;ihl += opt-&gt;opt.optlen&gt;&gt;<span class="number">2</span>;</span><br><span class="line">		ip_options_build(skb, &amp;opt-&gt;opt, daddr, rt, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* QOS优先级 */</span></span><br><span class="line">	skb-&gt;priority = sk-&gt;sk_priority;</span><br><span class="line">	skb-&gt;mark = sk-&gt;sk_mark;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Send it out. */</span></span><br><span class="line">    <span class="comment">/* 输出 */</span></span><br><span class="line">	<span class="keyword">return</span> ip_local_out(net, skb-&gt;sk, skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ip_send_unicast_reply</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">			   <span class="keyword">const</span> struct ip_options *sopt,</span></span></span><br><span class="line"><span class="function"><span class="params">			   __be32 daddr, __be32 saddr,</span></span></span><br><span class="line"><span class="function"><span class="params">			   <span class="keyword">const</span> struct ip_reply_arg *arg,</span></span></span><br><span class="line"><span class="function"><span class="params">			   <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_options_data</span> <span class="title">replyopts</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipcm_cookie</span> <span class="title">ipc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">flowi4</span> <span class="title">fl4</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rtable</span> *<span class="title">rt</span> = <span class="title">skb_rtable</span>(<span class="title">skb</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> = <span class="title">sock_net</span>(<span class="title">sk</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">nskb</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="keyword">int</span> oif;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取ip选项 */</span></span><br><span class="line">	<span class="keyword">if</span> (__ip_options_echo(&amp;replyopts.opt.opt, skb, sopt))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	ipc.addr = daddr;</span><br><span class="line">	ipc.opt = <span class="literal">NULL</span>;</span><br><span class="line">	ipc.tx_flags = <span class="number">0</span>;</span><br><span class="line">	ipc.ttl = <span class="number">0</span>;</span><br><span class="line">	ipc.tos = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 选项存在 */</span></span><br><span class="line">	<span class="keyword">if</span> (replyopts.opt.opt.optlen) &#123;</span><br><span class="line">		ipc.opt = &amp;replyopts.opt;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 源路由存在，设置下一跳ip地址为目的地址 */</span></span><br><span class="line">		<span class="keyword">if</span> (replyopts.opt.opt.srr)</span><br><span class="line">			daddr = replyopts.opt.opt.faddr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输出接口设置 */</span></span><br><span class="line">	oif = arg-&gt;bound_dev_if;</span><br><span class="line">	<span class="keyword">if</span> (!oif &amp;&amp; netif_index_is_l3_master(net, skb-&gt;skb_iif))</span><br><span class="line">		oif = skb-&gt;skb_iif;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查路由 */</span></span><br><span class="line">	flowi4_init_output(&amp;fl4, oif,</span><br><span class="line">			   IP4_REPLY_MARK(net, skb-&gt;mark),</span><br><span class="line">			   RT_TOS(arg-&gt;tos),</span><br><span class="line">			   RT_SCOPE_UNIVERSE, ip_hdr(skb)-&gt;protocol,</span><br><span class="line">			   ip_reply_arg_flowi_flags(arg),</span><br><span class="line">			   daddr, saddr,</span><br><span class="line">			   tcp_hdr(skb)-&gt;source, tcp_hdr(skb)-&gt;dest,</span><br><span class="line">			   arg-&gt;uid);</span><br><span class="line">	security_skb_classify_flow(skb, flowi4_to_flowi(&amp;fl4));</span><br><span class="line">	rt = ip_route_output_key(net, &amp;fl4);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(rt))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 根据skb更新sk的属性 */</span></span><br><span class="line">	inet_sk(sk)-&gt;tos = arg-&gt;tos;</span><br><span class="line"></span><br><span class="line">	sk-&gt;sk_priority = skb-&gt;priority;</span><br><span class="line">	sk-&gt;sk_protocol = ip_hdr(skb)-&gt;protocol;</span><br><span class="line">	sk-&gt;sk_bound_dev_if = arg-&gt;bound_dev_if;</span><br><span class="line">	sk-&gt;sk_sndbuf = sysctl_wmem_default;</span><br><span class="line">	sk-&gt;sk_mark = fl4.flowi4_mark;</span><br><span class="line">    <span class="comment">/* 数据追加到前一个skb或者新建skb后添加到发送队列 */</span></span><br><span class="line">	err = ip_append_data(sk, &amp;fl4, ip_reply_glue_bits, arg-&gt;iov-&gt;iov_base,</span><br><span class="line">			     len, <span class="number">0</span>, &amp;ipc, &amp;rt, MSG_DONTWAIT);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(err)) &#123;</span><br><span class="line">		ip_flush_pending_frames(sk);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果发送队列有skb，则计算校验和，发送 */</span></span><br><span class="line">	nskb = skb_peek(&amp;sk-&gt;sk_write_queue);</span><br><span class="line">	<span class="keyword">if</span> (nskb) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arg-&gt;csumoffset &gt;= <span class="number">0</span>)</span><br><span class="line">			*((__sum16 *)skb_transport_header(nskb) +</span><br><span class="line">			  arg-&gt;csumoffset) = csum_fold(csum_add(nskb-&gt;csum,</span><br><span class="line">								arg-&gt;csum));</span><br><span class="line">		nskb-&gt;ip_summed = CHECKSUM_NONE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 发送数据包 */</span></span><br><span class="line">		ip_push_pending_frames(sk, &amp;fl4);</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	ip_rt_put(rt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ip-push-pending-frames"><a href="#ip-push-pending-frames" class="headerlink" title="ip_push_pending_frames"></a>ip_push_pending_frames</h3><p>个函数会被icmp_push_reply，ip_send_reply，raw_sendmsg，和udp_push_pending_frames调用。该函数用于将该socket上的所有pending的IP分片，组成一个IP报文发送出去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ip_push_pending_frames</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>, *<span class="title">tmp_skb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> **<span class="title">tail_skb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> = <span class="title">inet_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> = <span class="title">sock_net</span>(<span class="title">sk</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_options</span> *<span class="title">opt</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtable</span> *<span class="title">rt</span> = (<span class="title">struct</span> <span class="title">rtable</span> *)<span class="title">inet</span>-&gt;<span class="title">cork</span>.<span class="title">dst</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">    __be16 df = <span class="number">0</span>;</span><br><span class="line">    __u8 ttl;</span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">/* 发送队列可能为空 */</span></span><br><span class="line">    <span class="keyword">if</span> ((skb = __skb_dequeue(&amp;sk-&gt;sk_write_queue)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">/* 获得分片链表 */</span></span><br><span class="line">    tail_skb = &amp;(skb_shinfo(skb)-&gt;frag_list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* move skb-&gt;data to ip header from ext header */</span></span><br><span class="line">    <span class="comment">/* 调整data指针位置 */</span></span><br><span class="line">    <span class="keyword">if</span> (skb-&gt;data skb_network_header(skb))</span><br><span class="line">        __skb_pull(skb, skb_network_offset(skb));</span><br><span class="line">     <span class="comment">/* 调整所有发送缓冲中的sk_buff的data指针位置，并更新第一个sk_buff的数据长度 */</span></span><br><span class="line">    <span class="keyword">while</span> ((tmp_skb = __skb_dequeue(&amp;sk-&gt;sk_write_queue)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        __skb_pull(tmp_skb, skb_network_header_len(skb));</span><br><span class="line">        *tail_skb = tmp_skb;</span><br><span class="line">        tail_skb = &amp;(tmp_skb-&gt;next);</span><br><span class="line">        skb-&gt;len = tmp_skb-&gt;len;</span><br><span class="line">        skb-&gt;data_len = tmp_skb-&gt;len;</span><br><span class="line">        skb-&gt;truesize = tmp_skb-&gt;truesize;</span><br><span class="line">        tmp_skb-&gt;destructor = <span class="literal">NULL</span>;</span><br><span class="line">        tmp_skb-&gt;sk = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Unless user demanded real pmtu discovery (IP_PMTUDISC_DO), we allow</span></span><br><span class="line"><span class="comment">     * to fragment the frame generated here. No matter, what transforms</span></span><br><span class="line"><span class="comment">     * how transforms change size of the packet, it will come out.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 允许本地分片 */</span></span><br><span class="line">    <span class="keyword">if</span> (inet-&gt;pmtudisc IP_PMTUDISC_DO)</span><br><span class="line">        skb-&gt;local_df = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* DF bit is set when we want to see DF on outgoing frames.</span></span><br><span class="line"><span class="comment">     * If local_df is set too, we still allow to fragment this frame</span></span><br><span class="line"><span class="comment">     * locally. */</span></span><br><span class="line">    <span class="comment">/* 不允许分片，或者不需要分片 */</span></span><br><span class="line">    <span class="keyword">if</span> (inet-&gt;pmtudisc &gt;= IP_PMTUDISC_DO ||</span><br><span class="line">     (skb-&gt;len = dst_mtu(&amp;rt-&gt;dst) &amp;&amp;</span><br><span class="line">     ip_dont_fragment(sk, &amp;rt-&gt;dst)))</span><br><span class="line">        df = htons(IP_DF);</span><br><span class="line">      <span class="comment">/* ip option 保存在cork中， 则使用cork中的option */</span></span><br><span class="line">    <span class="keyword">if</span> (inet-&gt;cork.flags &amp; IPCORK_OPT)</span><br><span class="line">        opt = inet-&gt;cork.opt;</span><br><span class="line">      <span class="comment">/* 选择合适的TTL值 */</span></span><br><span class="line">    <span class="keyword">if</span> (rt-&gt;rt_type == RTN_MULTICAST)</span><br><span class="line">        ttl = inet-&gt;mc_ttl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ttl = ip_select_ttl(inet, &amp;rt-&gt;dst);</span><br><span class="line">     <span class="comment">/* 得到IP报文头的地址 */</span> </span><br><span class="line">    iph = (struct iphdr *)skb-&gt;data;</span><br><span class="line">    <span class="comment">/* 初始化IP报文头的内容 */</span></span><br><span class="line">    iph-&gt;version = <span class="number">4</span>;</span><br><span class="line">    iph-&gt;ihl = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (opt) &#123;</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        填充IP option</span></span><br><span class="line"><span class="comment">        看到这里，可以发现opt只可能从cork中获得</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        iph-&gt;ihl = opt-&gt;optlen&gt;&gt;<span class="number">2</span>;</span><br><span class="line">        ip_options_build(skb, opt, inet-&gt;cork.addr, rt, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    iph-&gt;tos = inet-&gt;tos;</span><br><span class="line">    iph-&gt;frag_off = df;</span><br><span class="line">    ip_select_ident(iph, &amp;rt-&gt;dst, sk);</span><br><span class="line">    iph-&gt;ttl = ttl;</span><br><span class="line">    iph-&gt;protocol = sk-&gt;sk_protocol;</span><br><span class="line">    iph-&gt;saddr = rt-&gt;rt_src;</span><br><span class="line">    iph-&gt;daddr = rt-&gt;rt_dst;</span><br><span class="line"></span><br><span class="line">    skb-&gt;priority = sk-&gt;sk_priority;</span><br><span class="line">    skb-&gt;mark = sk-&gt;sk_mark;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Steal rt from cork.dst to avoid a pair of atomic_inc/atomic_dec</span></span><br><span class="line"><span class="comment">     * on dst refcount</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    inet-&gt;cork.dst = <span class="literal">NULL</span>;</span><br><span class="line">    skb_dst_set(skb, &amp;rt-&gt;dst);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iph-&gt;protocol == IPPROTO_ICMP)</span><br><span class="line">        icmp_out_count(net, ((struct icmphdr *)</span><br><span class="line">            skb_transport_header(skb))-&gt;type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Netfilter gets whole the not fragmented skb. */</span></span><br><span class="line">    <span class="comment">/* 发送数据 */</span></span><br><span class="line">    err = ip_local_out(skb);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err &gt; <span class="number">0</span>)</span><br><span class="line">            err = net_xmit_errno(err);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    ip_cork_release(inet);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    IP_INC_STATS(net, IPSTATS_MIB_OUTDISCARDS);</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ip-output"><a href="#ip-output" class="headerlink" title="ip_output"></a>ip_output</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ip_output</span><span class="params">(struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> = <span class="title">skb_dst</span>(<span class="title">skb</span>)-&gt;<span class="title">dev</span>;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    IP_UPD_PO_STATS(dev_net(dev), IPSTATS_MIB_OUT, skb-&gt;len);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    skb-&gt;dev = dev;</span><br><span class="line">    skb-&gt;protocol = htons(ETH_P_IP);   <span class="comment">//设置报文协议为IPV4</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> NF_HOOK_COND(NFPROTO_IPV4, NF_INET_POST_ROUTING, sk, skb, </span><br><span class="line">         <span class="literal">NULL</span>, dev,</span><br><span class="line">         ip_finish_output,   <span class="comment">//报文发送netfilter处理，如果允许则调用ip_finish_output</span></span><br><span class="line">         !(IPCB(skb)-&gt;flags &amp; IPSKB_REROUTED));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ip_finish_output2</span><span class="params">(struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dst_entry</span> *<span class="title">dst</span> = <span class="title">skb_dst</span>(<span class="title">skb</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rtable</span> *<span class="title">rt</span> = (<span class="title">struct</span> <span class="title">rtable</span> *)<span class="title">dst</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> = <span class="title">dst</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> hh_len = LL_RESERVED_SPACE(dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">neighbour</span> *<span class="title">neigh</span>;</span></span><br><span class="line">	u32 nexthop;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (rt-&gt;rt_type == RTN_MULTICAST) &#123;</span><br><span class="line">		IP_UPD_PO_STATS(dev_net(dev), IPSTATS_MIB_OUTMCAST, skb-&gt;len);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rt-&gt;rt_type == RTN_BROADCAST)</span><br><span class="line">		IP_UPD_PO_STATS(dev_net(dev), IPSTATS_MIB_OUTBCAST, skb-&gt;len);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* Be paranoid, rather than too clever. */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(skb_headroom(skb) &lt; hh_len &amp;&amp; dev-&gt;header_ops)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb2</span>;</span></span><br><span class="line"> </span><br><span class="line">		skb2 = skb_realloc_headroom(skb, LL_RESERVED_SPACE(dev));</span><br><span class="line">		<span class="keyword">if</span> (!skb2) &#123;</span><br><span class="line">			kfree_skb(skb);</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (skb-&gt;sk)</span><br><span class="line">			skb_set_owner_w(skb2, skb-&gt;sk);</span><br><span class="line">		consume_skb(skb);</span><br><span class="line">		skb = skb2;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	rcu_read_lock_bh();</span><br><span class="line">	nexthop = (__force u32) rt_nexthop(rt, ip_hdr(skb)-&gt;daddr);</span><br><span class="line">	neigh = __ipv4_neigh_lookup_noref(dev, nexthop);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!neigh))</span><br><span class="line">		neigh = __neigh_create(&amp;arp_tbl, &amp;nexthop, dev, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR(neigh)) &#123;</span><br><span class="line">		<span class="keyword">int</span> res = dst_neigh_output(dst, neigh, skb);	<span class="comment">//调用邻居子系统封装MAC头，并且调用二层发包函数完成报文发送</span></span><br><span class="line"> </span><br><span class="line">		rcu_read_unlock_bh();</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	rcu_read_unlock_bh();</span><br><span class="line"> </span><br><span class="line">	net_dbg_ratelimited(<span class="string">"%s: No header cache and no neighbour!\n"</span>,</span><br><span class="line">			    __func__);</span><br><span class="line">	kfree_skb(skb);</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>##　网卡</p>
<h3 id="dev-queue-xmit"><a href="#dev-queue-xmit" class="headerlink" title="dev_queue_xmit"></a>dev_queue_xmit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __dev_queue_xmit(struct sk_buff *skb, <span class="keyword">void</span> *accel_priv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> = <span class="title">skb</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netdev_queue</span> *<span class="title">txq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Qdisc</span> *<span class="title">q</span>;</span></span><br><span class="line">	<span class="keyword">int</span> rc = -ENOMEM;</span><br><span class="line"> </span><br><span class="line">	skb_reset_mac_header(skb);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (unlikely(skb_shinfo(skb)-&gt;tx_flags &amp; SKBTX_SCHED_TSTAMP))</span><br><span class="line">		__skb_tstamp_tx(skb, <span class="literal">NULL</span>, skb-&gt;sk, SCM_TSTAMP_SCHED);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* Disable soft irqs for various locks below. Also</span></span><br><span class="line"><span class="comment">	 * stops preemption for RCU.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rcu_read_lock_bh();</span><br><span class="line"> </span><br><span class="line">	skb_update_prio(skb);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* If device/qdisc don't need skb-&gt;dst, release it right now while</span></span><br><span class="line"><span class="comment">	 * its hot in this cpu cache.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/*这个地方看netdevcie的flag是否要去掉skb DST相关的信息，一般情况下这个flag是默认被设置的</span></span><br><span class="line"><span class="comment">	 *在alloc_netdev_mqs的时候，已经默认给设置了，其实个人认为这个路由信息也没有太大作用了...</span></span><br><span class="line"><span class="comment">	 *dev-&gt;priv_flags = IFF_XMIT_DST_RELEASE | IFF_XMIT_DST_RELEASE_PERM;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;priv_flags &amp; IFF_XMIT_DST_RELEASE)</span><br><span class="line">		skb_dst_drop(skb);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		skb_dst_force(skb);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">/*此处主要是取出此netdevice的txq和txq的Qdisc,Qdisc主要用于进行拥塞处理，一般的情况下，直接将</span></span><br><span class="line"><span class="comment">         *数据包发送给driver了，如果遇到Busy的状况，就需要进行拥塞处理了，就会用到Qdisc*/</span></span><br><span class="line">	txq = netdev_pick_tx(dev, skb, accel_priv);</span><br><span class="line">	q = rcu_dereference_bh(txq-&gt;qdisc);</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NET_CLS_ACT</span></span><br><span class="line">	skb-&gt;tc_verd = SET_TC_AT(skb-&gt;tc_verd, AT_EGRESS);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	trace_net_dev_queue(skb);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*如果Qdisc有对应的enqueue规则，就会调用__dev_xmit_skb，进入带有拥塞的控制的Flow，注意这个地方，虽然是走拥塞控制的</span></span><br><span class="line"><span class="comment">	 *Flow但是并不一定非得进行enqueue操作啦，只有Busy的状况下，才会走Qdisc的enqueue/dequeue操作进行</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (q-&gt;enqueue) &#123;</span><br><span class="line">		rc = __dev_xmit_skb(skb, q, dev, txq);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* The device has no queue. Common case for software devices:</span></span><br><span class="line"><span class="comment">	   loopback, all the sorts of tunnels...</span></span><br><span class="line"><span class="comment">	   Really, it is unlikely that netif_tx_lock protection is necessary</span></span><br><span class="line"><span class="comment">	   here.  (f.e. loopback and IP tunnels are clean ignoring statistics</span></span><br><span class="line"><span class="comment">	   counters.)</span></span><br><span class="line"><span class="comment">	   However, it is possible, that they rely on protection</span></span><br><span class="line"><span class="comment">	   made by us here.</span></span><br><span class="line"><span class="comment">	   Check this and shot the lock. It is not prone from deadlocks.</span></span><br><span class="line"><span class="comment">	   Either shot noqueue qdisc, it is even simpler 8)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	 </span><br><span class="line">	<span class="comment">/*此处是设备没有Qdisc的，实际上没有enqueue/dequeue的规则，无法进行拥塞控制的操作，</span></span><br><span class="line"><span class="comment">	 *对于一些loopback/tunnel interface比较常见，判断下设备是否处于UP状态*/</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;flags &amp; IFF_UP) &#123;</span><br><span class="line">		<span class="keyword">int</span> cpu = smp_processor_id(); <span class="comment">/* ok because BHs are off */</span></span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (txq-&gt;xmit_lock_owner != cpu) &#123;</span><br><span class="line"> </span><br><span class="line">			<span class="keyword">if</span> (__this_cpu_read(xmit_recursion) &gt; RECURSION_LIMIT)</span><br><span class="line">				<span class="keyword">goto</span> recursion_alert;</span><br><span class="line">			skb = validate_xmit_skb(skb, dev);</span><br><span class="line">			<span class="keyword">if</span> (!skb)</span><br><span class="line">				<span class="keyword">goto</span> drop;</span><br><span class="line"> </span><br><span class="line">			HARD_TX_LOCK(dev, txq, cpu);</span><br><span class="line">                       <span class="comment">/*这个地方判断一下txq不是stop状态，那么就直接调用dev_hard_start_xmit函数来发送数据*/</span></span><br><span class="line">			<span class="keyword">if</span> (!netif_xmit_stopped(txq)) &#123;</span><br><span class="line">				__this_cpu_inc(xmit_recursion);</span><br><span class="line">				skb = dev_hard_start_xmit(skb, dev, txq, &amp;rc);</span><br><span class="line">				__this_cpu_dec(xmit_recursion);</span><br><span class="line">				<span class="keyword">if</span> (dev_xmit_complete(rc)) &#123;</span><br><span class="line">					HARD_TX_UNLOCK(dev, txq);</span><br><span class="line">					<span class="keyword">goto</span> out;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			HARD_TX_UNLOCK(dev, txq);</span><br><span class="line">			net_crit_ratelimited(<span class="string">"Virtual device %s asks to queue packet!\n"</span>,</span><br><span class="line">					     dev-&gt;name);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* Recursion is detected! It is possible,</span></span><br><span class="line"><span class="comment">			 * unfortunately</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">recursion_alert:</span><br><span class="line">			net_crit_ratelimited(<span class="string">"Dead loop on virtual device %s, fix it urgently!\n"</span>,</span><br><span class="line">					     dev-&gt;name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	rc = -ENETDOWN;</span><br><span class="line">drop:</span><br><span class="line">	rcu_read_unlock_bh();</span><br><span class="line"> </span><br><span class="line">	atomic_long_inc(&amp;dev-&gt;tx_dropped);</span><br><span class="line">	kfree_skb_list(skb);</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">out:</span><br><span class="line">	rcu_read_unlock_bh();</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dev-xmit-skb"><a href="#dev-xmit-skb" class="headerlink" title="__dev_xmit_skb"></a>__dev_xmit_skb</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __dev_xmit_skb(struct sk_buff *skb, struct Qdisc *q,</span><br><span class="line">				 struct net_device *dev,</span><br><span class="line">				 struct netdev_queue *txq)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">spinlock_t</span> *root_lock = qdisc_lock(q);</span><br><span class="line">	<span class="keyword">bool</span> contended;</span><br><span class="line">	<span class="keyword">int</span> rc;</span><br><span class="line"> </span><br><span class="line">	qdisc_pkt_len_init(skb);</span><br><span class="line">	qdisc_calculate_pkt_len(skb, q);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Heuristic to force contended enqueues to serialize on a</span></span><br><span class="line"><span class="comment">	 * separate lock before trying to get qdisc main lock.</span></span><br><span class="line"><span class="comment">	 * This permits __QDISC___STATE_RUNNING owner to get the lock more</span></span><br><span class="line"><span class="comment">	 * often and dequeue packets faster.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	contended = qdisc_is_running(q);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(contended))</span><br><span class="line">		spin_lock(&amp;q-&gt;busylock);</span><br><span class="line"> </span><br><span class="line">	spin_lock(root_lock);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*这个地方主要是判定Qdisc的state: __QDISC_STATE_DEACTIVATED,如果处于非活动的状态，就DROP这个包，返回NET_XMIT_DROP</span></span><br><span class="line"><span class="comment">	 *一般情况下带有Qdisc策略的interface，在被close的时候才会打上这个flag */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(test_bit(__QDISC_STATE_DEACTIVATED, &amp;q-&gt;state))) &#123;</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">		rc = NET_XMIT_DROP;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((q-&gt;flags &amp; TCQ_F_CAN_BYPASS) &amp;&amp; !qdisc_qlen(q) &amp;&amp;</span><br><span class="line">		   qdisc_run_begin(q)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * This is a work-conserving queue; there are no old skbs</span></span><br><span class="line"><span class="comment">		 * waiting to be sent out; and the qdisc is not running -</span></span><br><span class="line"><span class="comment">		 * xmit the skb directly.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">                <span class="comment">/* 结合注释以及code来看，此处必须满足3个调节才可以进来，</span></span><br><span class="line"><span class="comment">                 * 1.flag必须有TCQ_F_CAN_BYPASS，默认条件下是有的，表明可以By PASS Qdisc规则</span></span><br><span class="line"><span class="comment">                 * 2.q的len为0，也就是说Qdisc中一个包也没有</span></span><br><span class="line"><span class="comment">                 * 3.Qdisc 起初并没有处于running的状态，然后置位Running！</span></span><br><span class="line"><span class="comment">                 * 满足上述3个条件调用sch_direct_xmit</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">		qdisc_bstats_update(q, skb);</span><br><span class="line"> </span><br><span class="line">                <span class="comment">/*这个函数*/</span></span><br><span class="line">		<span class="keyword">if</span> (sch_direct_xmit(skb, q, dev, txq, root_lock, <span class="literal">true</span>)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (unlikely(contended)) &#123;</span><br><span class="line">				spin_unlock(&amp;q-&gt;busylock);</span><br><span class="line">				contended = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			__qdisc_run(q);</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			qdisc_run_end(q);</span><br><span class="line"> </span><br><span class="line">		rc = NET_XMIT_SUCCESS;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	</span><br><span class="line">	   <span class="comment">/*如果上述3个条件其中任何一个或者多个不满足，就要进行enqueue操作了，这个地方其实就是表明通讯出现拥塞，需要进行管理了</span></span><br><span class="line"><span class="comment">	    *如果q不是运行状态，就设置成运行状况，如果一直是运行状态，那么就不用管了！*/</span></span><br><span class="line">		rc = q-&gt;enqueue(skb, q) &amp; NET_XMIT_MASK;</span><br><span class="line">		<span class="keyword">if</span> (qdisc_run_begin(q)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (unlikely(contended)) &#123;</span><br><span class="line">				spin_unlock(&amp;q-&gt;busylock);</span><br><span class="line">				contended = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			__qdisc_run(q);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock(root_lock);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(contended))</span><br><span class="line">		spin_unlock(&amp;q-&gt;busylock);</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dev-hard-start-xmit"><a href="#dev-hard-start-xmit" class="headerlink" title="dev_hard_start_xmit"></a>dev_hard_start_xmit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct sk_buff *<span class="title">dev_hard_start_xmit</span><span class="params">(struct sk_buff *first, struct net_device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">				    struct netdev_queue *txq, <span class="keyword">int</span> *ret)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span> = <span class="title">first</span>;</span></span><br><span class="line">	<span class="keyword">int</span> rc = NETDEV_TX_OK;</span><br><span class="line">       <span class="comment">/*此处skb为什么会有链表呢？*/</span></span><br><span class="line">	<span class="keyword">while</span> (skb) &#123;</span><br><span class="line">	      <span class="comment">/*取出skb的下一个数据单元*/</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">next</span> = <span class="title">skb</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">              <span class="comment">/*置空，待发送数据包的next*/</span></span><br><span class="line">		skb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		</span><br><span class="line">	       <span class="comment">/*将此数据包送到driver Tx函数，因为dequeue的数据也会从这里发送，所以会有netx！*/</span></span><br><span class="line">		rc = xmit_one(skb, dev, txq, next != <span class="literal">NULL</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*如果发送不成功，next还原到skb-&gt;next 退出*/</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!dev_xmit_complete(rc))) &#123;</span><br><span class="line">			skb-&gt;next = next;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">                <span class="comment">/*如果发送成功，把next置给skb，一般的next为空 这样就返回，如果不为空就继续发！*/</span></span><br><span class="line">		skb = next;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*如果txq被stop，并且skb需要发送，就产生TX Busy的问题！*/</span></span><br><span class="line">		<span class="keyword">if</span> (netif_xmit_stopped(txq) &amp;&amp; skb) &#123;</span><br><span class="line">			rc = NETDEV_TX_BUSY;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">	*ret = rc;</span><br><span class="line">	<span class="keyword">return</span> skb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xmit_one</span><span class="params">(struct sk_buff *skb, struct net_device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">		    struct netdev_queue *txq, <span class="keyword">bool</span> more)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> len;</span><br><span class="line">	<span class="keyword">int</span> rc;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*如果有抓包的工具的话，这个地方会进行抓包，such as Tcpdump*/</span></span><br><span class="line">	<span class="keyword">if</span> (!list_empty(&amp;ptype_all))</span><br><span class="line">		dev_queue_xmit_nit(skb, dev);</span><br><span class="line"> </span><br><span class="line">	len = skb-&gt;len;</span><br><span class="line">	trace_net_dev_start_xmit(skb, dev);</span><br><span class="line">        <span class="comment">/*调用netdev_start_xmit，快到driver的tx函数了*/</span></span><br><span class="line">	rc = netdev_start_xmit(skb, dev, txq, more);</span><br><span class="line">	trace_net_dev_xmit(skb, rc, dev, len);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> netdev_tx_t <span class="title">netdev_start_xmit</span><span class="params">(struct sk_buff *skb, struct net_device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">					    struct netdev_queue *txq, <span class="keyword">bool</span> more)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device_ops</span> *<span class="title">ops</span> = <span class="title">dev</span>-&gt;<span class="title">netdev_ops</span>;</span></span><br><span class="line">	<span class="keyword">int</span> rc;</span><br><span class="line">	<span class="comment">/*__netdev_start_xmit 里面就完全是使用driver 的ops去发包了，其实到此为止，一个skb已经从netdevice</span></span><br><span class="line"><span class="comment">	 *这个层面送到driver层了，接下来会等待driver的返回*/</span></span><br><span class="line">	rc = __netdev_start_xmit(ops, skb, dev, more);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*如果返回NETDEV_TX_OK，那么会更新下Txq的trans时间戳哦，txq-&gt;trans_start = jiffies;*/</span></span><br><span class="line">	<span class="keyword">if</span> (rc == NETDEV_TX_OK)</span><br><span class="line">		txq_trans_update(txq);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">netdev_tx_t</span> __netdev_start_xmit(<span class="keyword">const</span> struct net_device_ops *ops,</span><br><span class="line">					      struct sk_buff *skb, struct net_device *dev,</span><br><span class="line">					      <span class="keyword">bool</span> more)</span><br><span class="line">&#123;</span><br><span class="line">	skb-&gt;xmit_more = more ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> ops-&gt;ndo_start_xmit(skb, dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://blog.51cto.com/yaoyang/1359420" target="_blank" rel="noopener">http://blog.51cto.com/yaoyang/1359420</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/10/04/network/network/" rel="next" title=".network">
                <i class="fa fa-chevron-left"></i> .network
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/10/04/nginx/ds/request/" rel="prev" title=".request">
                .request <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">82</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp-层数据"><span class="nav-number">1.</span> <span class="nav-text">tcp 层数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp-sendmsg"><span class="nav-number">1.1.</span> <span class="nav-text">tcp_sendmsg</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp-push"><span class="nav-number">2.</span> <span class="nav-text">tcp_push</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp-write-xmit"><span class="nav-number">3.</span> <span class="nav-text">tcp_write_xmit</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp-init-tso-segs-函数"><span class="nav-number">3.1.</span> <span class="nav-text">tcp_init_tso_segs()函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp-transmit-skb"><span class="nav-number">4.</span> <span class="nav-text">tcp_transmit_skb</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ip层数据传输"><span class="nav-number">5.</span> <span class="nav-text">ip层数据传输</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ip-queue-xmit"><span class="nav-number">5.1.</span> <span class="nav-text">ip_queue_xmit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ip-push-pending-frames"><span class="nav-number">5.2.</span> <span class="nav-text">ip_push_pending_frames</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#ip-output"><span class="nav-number"></span> <span class="nav-text">ip_output</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dev-queue-xmit"><span class="nav-number">0.1.</span> <span class="nav-text">dev_queue_xmit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dev-xmit-skb"><span class="nav-number">0.2.</span> <span class="nav-text">__dev_xmit_skb</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dev-hard-start-xmit"><span class="nav-number">0.3.</span> <span class="nav-text">dev_hard_start_xmit</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
