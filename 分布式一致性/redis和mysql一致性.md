# redis 和mysql 一致性
## 结论
redis 和mysql 中的数据不可能保证一致,只能尽量保证数据是一致的.所以有线性一致性的数据,可以选择etcd/zk来存储数据.
下面从几个方面来说明
## 同步复制和异步复制
同步复制时需要将数据同步到从节点后再提交,而异步复制系统则提交和同步是分离的.mysql提供了同步,半同步和异步的方式.而redis只提供了异步复制,这样在主节点失效后,在做主从切换的时候,主节点的变更没有复制到从节点就会导致数据丢失,此时即使协议上能完全保证mysql-redis完全一致,也会由于数据丢失导致不一致. 所以下面从以下几个方面来考虑降低不一致的概率

## 业务场景
* 有没有热点数据
* 并发量是不是高

### 旁路更新
旁路更新:
读数据: 查询redis,如果miss,读取db,更新redis
写数据: 更新db,删除redis
产生不一致的情况:更新和删除操作操作在读取和更新redis之间,但是读db一般比更新快,所以概率会小一点

好在redis本身提供了事务,但是redis的事务是不加锁的方案
旁路更新2:
读数据: 查询redis,如果miss,watch key,multi,读取db,更新redis,exec
写数据: 更新db,删除redis
在读取db之前设置watch key,如果提交失败,可以再读一次,但是如果对于读的并发很高,会在某个瞬间多次读数据库,不过概率应该比较低

旁路更新不适合有热点数据并且读写入很高的场景,但是对于读并发较高的场景很合适.
### 串行化
串行化,将对同一个key的操作串行化
#### 同步的串行化
每一层服务都做一致性hash,然后在同一个进程中hash处理key,保证同一个key对应的操作串行化,但是这样在有较大的并发且有热点数据的时候有可能会hang住

#### 异步串行化
redis的操作通过一个后台服务来处理,通过binlog同步写入的数据到redis.但是这时候对于读操作仍然需要触发,此时读操作实际就是load数据到redis,在redis没有命中的时候,将读操作转化为load操作放入队列中,后台服务将同一个key的操作在同一个线程中处理.在操作结束后返回数据.
考虑一种场景,对于读操作如果没有命中redis,直接请求数据库,然后将数据返回,同时异步发送到更新服务中.这时能比较及时的返回数据(减少了一次rpc),但是由于此时的数据可能和db不一致,所以这个数据可能是错误的,如果数据本身是有版本号的是不是想想就比较简单了呢,通过cas的操作来比较数据,然而redis并不支持数据的版本操作比较.所以这个方案放弃

串行化可以在更新的时候就将数据写入,通常由于局部性原理,应该也比较容易被读到,这种情况下读写较高的请求都可以


